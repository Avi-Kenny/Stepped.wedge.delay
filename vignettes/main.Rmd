---
title: "Stepped wedge lagged effect simulation"
author: "Avi Kenny"
date: "April 25, 2020"
output: rmarkdown::word_document
vignette: >
  %\VignetteIndexEntry{main}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options:
  chunk_output_type: console
---



# SETUP: Load packages
```{r}

# devtools::install_github(
#   repo = "Avi-Kenny/simba",
#   lib = '/home/akenny/R_lib',
#   dependencies = TRUE
# )

library(z.stepped.wedge)
library(dplyr)
library(magrittr)
library(ggplot2)
library(nlme)
library(geepack)
library(stringr)
library(simba)
library(parallel)

# detach(package:simba)

```



# Set code blocks to run
```{r}

run_main <- TRUE
run_misc <- FALSE

```



# MAIN: Simulation setup
```{r}
if ( run_main ) {
  
  print(paste("Number of available cores:", parallel::detectCores()))
  print(paste("SLURM_ARRAY_JOB_ID:", Sys.getenv("SLURM_ARRAY_JOB_ID")))
  print(paste("SLURM_CPUS_ON_NODE:", Sys.getenv("SLURM_CPUS_ON_NODE")))
  print(paste("SLURM_NODELIST:", Sys.getenv("SLURM_NODELIST")))
  print(paste("SLURM_NNODES:", Sys.getenv("SLURM_NNODES")))
  print(paste("SLURM_NTASKS:", Sys.getenv("SLURM_NTASKS")))
  
  sim <- new_sim()
  
  sim %<>% set_config(
    # num_sim = 1000,
    num_sim = 10, # !!!!! Testing
    parallel = "none",
    # parallel = "outer",
    packages = c("magrittr", "stringr", "geepack", "nlme", "z.stepped.wedge")
  )
  
  sim %<>% add_constants(
    alpha = log(0.1),
    sigma = 0.3 # Same variance as a Bern(0.1) rv
  )
  
  # # !!!!! Testing
  # sim %<>% set_levels(
  #   n_clusters = 24,
  #   n_time_points = 7,
  #   n_ind_per_cluster = 20,
  #   theta = log(0.5),
  #   d = 0,
  #   tau = 0,
  #   analysis_type = c("2S LM", "2S GEE", "2S LMM")
  # )
  
  # # All levels
  # sim %<>% set_levels(
  #   n_clusters = c(24, 48),
  #   n_time_points = c(5, 7, 9),
  #   n_ind_per_cluster = c(20, 50, 100),
  #   theta = log(0.5),
  #   d = c(0, 0.5, 1.4),
  #   tau = c(0, 0.2, 0.4), # Excluding 0.1, 0.3, 0.5
  #   analysis_type = c("2S LM", "2S GEE", "2S LMM") # Excluding "PP SPL", "FX SPL"
  # )
  
  # Negative log lik corresponding to two-stage dissertation approach
  sim %<>% add_method(
    "neg_log_lik",
    function(theta, d, J, theta_l_hat, sigma_l_hat) {
      
      l_times <- 1:(J-1)
      mu_d <- 1-exp(-l_times/d)
      log_lik <- -0.5 * t(theta_l_hat - theta*mu_d) %*%
        solve(sigma_l_hat) %*% (theta_l_hat - theta*mu_d)
      
      return (-1*log_lik)
      
    }
  )
  
  # Negative log lik corresponding to two-stage spline approach
  sim %<>% add_method(
    "neg_log_lik_spl",
    function(theta, p_x, p_y, J, theta_l_hat, sigma_l_hat) {
      
      # !!!!! g_x hard-coded for now
      g_x <- J
      
      l_times <- 1:(J-1)
      mu_spl <- sapply(l_times, function(l) {
        I1 <- ifelse(0<l & l<=p_x, 1, 0)
        I2 <- ifelse(p_x<l & l<=g_x, 1, 0)
        I3 <- ifelse(g_x<l, 1, 0)
        (p_y/p_x)*l*I1 + ((1-p_y)*l+g_x+p_y-p_x-1)/(g_x-p_x)*I2 + I3
      })
      
      log_lik <- -0.5 * t(theta_l_hat - theta*mu_spl) %*%
        solve(sigma_l_hat) %*% (theta_l_hat - theta*mu_spl)
      
      return (-1*log_lik)
      
    }
  )
  
  sim %<>% add_creator(generate_dataset)
  sim %<>% add_script(one_simulation)
  
}
```



# !!!!! TEMP TESTING
```{r}
if ( run_main ) {
  
  start_time <- Sys.time()
  
  # Set levels
  sim %<>% set_levels(
    n_clusters = 12,
    n_time_points = 7,
    n_ind_per_cluster = 100,
    theta = log(0.5),
    d = 0.5,
    tau = 0,
    analysis_type = c("2S LM")
  )
  
  sim %<>% run("one_simulation")
  
  summary(
    sim_obj = sim,
    bias = list(name="bias_theta", truth="theta", estimate="theta_hat")
  )
  
  print("")
  print(difftime(Sys.time(), start_time))
  
}
```



# MAIN: Reproduce table 3.1
```{r}
if ( run_main ) {
  
  start_time <- Sys.time()
  
  # Set levels
  sim %<>% set_levels(
    n_clusters = c(12,24,48),
    n_time_points = 7,
    n_ind_per_cluster = 100,
    theta = log(0.5),
    d = c(0, 0.5, 1.4),
    tau = 0,
    analysis_type = c("2S LM", "IG LM")
  )
  
  sim %<>% run("one_simulation")
  
  summary(
    sim_obj = sim,
    bias = list(name="bias_theta", truth="theta", estimate="theta_hat")
  )
  
  print("")
  print(difftime(Sys.time(), start_time))
  
}
```



# MAIN: Reproduce table 3.2
```{r}
if ( run_main ) {
  
  start_time <- Sys.time()
  
  # Set levels
  sim %<>% set_levels(
    n_clusters = 24,
    n_time_points = c(5,7,9),
    n_ind_per_cluster = 100,
    theta = log(0.5),
    d = c(0, 0.5, 1.4),
    tau = 0,
    analysis_type = c("2S LM", "IG LM")
  )
  
  sim %<>% run("one_simulation")
  
  summary(
    sim_obj = sim,
    bias = list(name="bias_theta", truth="theta", estimate="theta_hat")
  )
  
  print("")
  print(difftime(Sys.time(), start_time))
  
}
```



# MAIN: Reproduce table 3.3
```{r}
if ( run_main ) {
  
  start_time <- Sys.time()
  
  # Set levels
  sim %<>% set_levels(
    n_clusters = 24,
    n_time_points = 7,
    n_ind_per_cluster = c(20,50,100),
    theta = log(0.5),
    d = c(0, 0.5, 1.4),
    tau = 0,
    analysis_type = c("2S LM", "IG LM")
  )
  
  sim %<>% run("one_simulation")
  
  summary(
    sim_obj = sim,
    bias = list(name="bias_theta", truth="theta", estimate="theta_hat")
  )
  
  print("")
  print(difftime(Sys.time(), start_time))
  
}
```



# MAIN: Reproduce table 3.4
```{r}
if ( run_main ) {
  
  start_time <- Sys.time()
  
  # Set levels
  sim %<>% set_levels(
    n_clusters = c(12,24,48),
    n_time_points = 7,
    n_ind_per_cluster = 100,
    theta = log(0.5),
    d = c(0.5, 1.4),
    tau = 0,
    analysis_type = c("2S LM")
  )
  
  sim %<>% run("one_simulation")
  
  summary(
    sim_obj = sim,
    bias = list(name="bias_d", truth="d", estimate="d_hat")
  )
  
  print("")
  print(difftime(Sys.time(), start_time))
  
}
```



# MAIN: Reproduce table 3.5
```{r}
if ( run_main ) {
  
  start_time <- Sys.time()
  
  # Set levels
  sim %<>% set_levels(
    n_clusters = 24,
    n_time_points = c(5,7,9),
    n_ind_per_cluster = 100,
    theta = log(0.5),
    d = c(0.5, 1.4),
    tau = 0,
    analysis_type = c("2S LM")
  )
  
  sim %<>% run("one_simulation")
  
  summary(
    sim_obj = sim,
    bias = list(name="bias_d", truth="d", estimate="d_hat")
  )
  
  print("")
  print(difftime(Sys.time(), start_time))
  
}
```



# MAIN: Reproduce table 3.6
```{r}
if ( run_main ) {
  
  start_time <- Sys.time()
  
  # Set levels
  sim %<>% set_levels(
    n_clusters = 24,
    n_time_points = 7,
    n_ind_per_cluster = c(20,50,100),
    theta = log(0.5),
    d = c(0.5, 1.4),
    tau = 0,
    analysis_type = c("2S LM")
  )
  
  sim %<>% run("one_simulation")
  
  summary(
    sim_obj = sim,
    bias = list(name="bias_d", truth="d", estimate="d_hat")
  )
  
  print("")
  print(difftime(Sys.time(), start_time))
  
}
```



# !!!!! TESTING: Two-stage spline
```{r}
if ( run_main ) {
  
  start_time <- Sys.time()
  
  # Set levels
  sim %<>% set_levels(
    n_clusters = 24,
    n_time_points = 7,
    n_ind_per_cluster = 100,
    theta = log(0.5),
    d = c(0, 0.5, 1.4),
    tau = 0,
    analysis_type = c("2S SPL")
  )
  
  sim %<>% run("one_simulation")
  
  summary(
    sim_obj = sim,
    bias = list(name="bias_theta", truth="theta", estimate="theta_hat")
  )
  
  print("")
  print(difftime(Sys.time(), start_time))
  
}
```



# MAIN: Simulation 2: Effect lag exists but is not accounted for
```{r}
if ( run_main ) {
  
  # d \in {0.5, 1.4}
  # I, J, K, tau^2, theta, alpha, N as above
  # Same outputs as above
  
  # Check: The short and long lags should result in log RRs of log(0.55) and log(0.70) at the first time step
  
  # !!!!!
  
}
```



# MAIN: Simulation 3: Effect lag exists and is accounted for
```{r}
if ( run_main ) {
  
  # d \in {0.5, 1.4}
  # I, J, K, tau^2, theta, alpha, N as above
  # Same outputs as above
  
  # Check: The short and long lags should result in log RRs of log(0.55) and log(0.70) at the first time step
  
  # !!!!!
  
}
```



# MISC: Check MLE calculation
```{r}
if ( run_misc ) {
  
  J <- 5
  theta_hat_l <- matrix(1:J,ncol=1)
  mu_d <- matrix(0.3*c(3:(J+2)),ncol=1)
  A <- matrix(runif(J^2)*2-1, ncol=J)
  sigma_inv <- t(A) %*% A

  neg_log_lik <- function(theta) {
    return(
      (1/2) * t(theta_hat_l-(theta*mu_d)) %*%
        sigma_inv %*%
        (theta_hat_l-(theta*mu_d))
    )
  }
  
  optim(
    par = 6,
    fn = function(x) {
      return ( neg_log_lik(x) )
    },
    method = "BFGS"
  )
  
  mle_ank <- (
    (t(theta_hat_l) %*% sigma_inv %*% mu_d) +
      t((t(theta_hat_l) %*% sigma_inv %*% mu_d))) /
      (2* t(mu_d) %*% sigma_inv %*% mu_d)
  mle_tsg <- (t(theta_hat_l) %*% sigma_inv %*% mu_d) /
             (t(mu_d) %*% sigma_inv %*% mu_d)
  
  print(mle_ank)
  print(mle_tsg)
  
}
```



# MISC: Linear spline alternative
```{r}
if ( run_misc ) {
  
  ggplot(data.frame(x=c(0,8)), aes(x=x)) +
    # stat_function(fun = function(x) {
    #   return(ifelse(x>=2,1,0))
    # }, aes(color="Step function")) +
    # stat_function(fun = function(x) {
    #   d = 1
    #   I = ifelse(x>=1, 1, 0)
    #   return(I * (1-exp(-(x-1)/d)))
    # }, aes(color="Current function")) +
    stat_function(fun = function(x) {
      i1 = ifelse(x>=0 & x<2, 1, 0)
      i2 = ifelse(x>=2 & x<5, 1, 0)
      i3 = ifelse(x>=5, 1, 0)
      return( i1*(0.4*x) + i2*((0.2/3)*x + (2/3)) + i3 )
    }) +
    # }, aes(color="Linear spline")) +
    geom_point(aes(x=5, y=1), colour="green") +
    geom_point(aes(x=2, y=0.8), colour="purple") +
    labs(
      title = "Linear spline model for R_ij",
      # color = "Type",
      y = "R_ij (% of treatment effect achieved)",
      x = "Time (t_ij)"
    )
    
}
```


# ARCHIVE: Old code (to recycle) from run_analysis
```{r}
if ( FALSE ) {
  
  # summary(
  #   sim_obj = sim,
  #   sd = list(
  #     list(name="sd_theta_hat", x="theta_hat"),
  #     list(name="sd_d_hat", x="d_hat")
  #   ),
  #   bias = list(
  #     list(name="bias_theta", truth="theta", estimate="theta_hat"),
  #     list(name="bias_d", truth="d", estimate="d_hat")
  #   ),
  #   coverage = list(
  #     list(name="cov_theta", truth="theta",
  #          estimate="theta_hat", se="se_theta_hat"),
  #     list(name="cov_d", truth="d", estimate="d_hat", se="se_d_hat")
  #   )
  # )
  
  # Plots
  # plot_sw_design(data_1)
  # plot_outcome(data_1, type="no error")
  # plot_outcome(data_1, type="realized")
  
  # # Binomial GLM
  # model_binomial_gee1 <- geeglm(
  #   y ~ factor(j) + factor(x_ij),
  #   data = data$data,
  #   id = i,
  #   family = binomial(link = "log"),
  #   corstr = "exchangeable"
  # )
  # summary(model_binomial_gee1)
  # system.time(
  #   model_binomial_gee2 <- geeglm(
  #     y ~ factor(j) + factor(l),
  #     data = data$data,
  #     id = i,
  #     family = binomial(link = "log"),
  #     corstr = "exchangeable"
  #   )
  # )
  # summary(model_gee2)
  
  # # Only estimate theta (step function)
  # model_normal_gee1 <- geeglm(
  #   y ~ factor(j) + factor(x_ij),
  #   data = data$data,
  #   id = i,
  #   family = "gaussian",
  #   corstr = "exchangeable"
  # )
  # summary(model_normal_gee1)
  
}
```
