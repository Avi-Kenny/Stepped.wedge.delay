---
title: "Stepped wedge lagged effect simulation"
author: "Avi Kenny"
date: "April 25, 2020"
output: rmarkdown::word_document
vignette: >
  %\VignetteIndexEntry{main}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options:
  chunk_output_type: console
---



# SETUP: Load packages
```{r}

# devtools::install_github(
#   repo = "Avi-Kenny/simba",
#   lib = '/home/akenny/R_lib',
#   dependencies = TRUE
# )

library(z.stepped.wedge)
library(dplyr)
library(magrittr)
library(ggplot2)
library(nlme)
library(geepack)
library(stringr)
library(simba)
library(parallel)
library(numDeriv)

```



# Set code blocks to run
```{r}

run_main <- TRUE
run_misc <- FALSE

```



# MAIN: Simulation 1: No effect lag present
```{r}
if ( run_main ) {
  
  start_time <- Sys.time()
  
  sim <- new_sim()
  
  sim %<>% set_config(
    num_sim = 10,
    # num_sim = 1000,
    parallel = "none",
    # parallel = "outer",
    packages = c("magrittr", "stringr", "geepack", "numDeriv")
  )
  
  sim %<>% add_constants(
    d = 0,
    alpha = log(0.1)
  )
  
  sim %<>% set_levels(
    # n_clusters = c(96),
    # n_time_points = c(7),
    # n_ind_per_cluster = c(50),
    n_clusters = c(24, 48, 96),
    n_time_points = c(5, 7, 9),
    n_ind_per_cluster = c(20, 50, 100),
    theta = log(0.5)
  )
  
  # tau^2 \in {0, 0.01, 0.04, 0.09, 0.16, 0.25}
  # N := # of simulations = 1,000
  # Output bias and precision for intervention effect estimate
  # Output bias of estimate of lag duration
  
  sim %<>% add_creator(generate_dataset)
  
  # Use numerical ML to estimate mu_hat
  sim %<>% add_method(
    "neg_log_lik",
    function(theta, d, J, theta_l_hat, sigma_l_hat) {
      
      l_times <- 1:(J-1)
      mu_d <- 1-exp(-l_times/d)
      log_lik <- -0.5 * t(theta_l_hat - theta*mu_d) %*%
        solve(sigma_l_hat) %*% (theta_l_hat - theta*mu_d)
      
      return (-1*log_lik)
      
    }
  )
  
  sim %<>% add_script(
    "one_simulation",
    function(L,C) {
      
      # !!!!! DEBUGGING
      # print(L)
      
print("Check 0")
      # Generate normal data
      data <- generate_dataset(
        alpha = C$alpha,
        tau = 0,
        theta = L$theta,
        d = C$d,
        n_clusters = L$n_clusters,
        n_time_points = L$n_time_points,
        n_ind_per_cluster = L$n_ind_per_cluster,
        type = "normal",
        sigma = 0.1
      )
      
      # Run normal linear model
      model_normal_lm2 <- lm(
        y ~ factor(j) + factor(l),
        data = data$data
      )
      
      # Extract coefficients and SEs
      coeff_names <- names(model_normal_lm2$coefficients)
      theta_l_hat <- as.numeric(model_normal_lm2$coefficients)
      sigma_l_hat <- vcov(model_normal_lm2)
      indices <- c(1:length(coeff_names))[str_sub(coeff_names,1,9)=="factor(l)"]
      coeff_names <- coeff_names[indices]
      theta_l_hat <- theta_l_hat[indices]
      sigma_l_hat <- sigma_l_hat[indices,indices]
      
      # Generate ML estimates of theta and d
      opt <- optim(
        par = c(theta=-0.1, d=1),
        fn = function(par) {
          return (
            neg_log_lik(
              theta = par[1],
              d = par[2],
              J = L$n_time_points,
              theta_l_hat = theta_l_hat,
              sigma_l_hat = sigma_l_hat
            )
          )
        }
      )
      theta_hat <- opt$par[["theta"]]
      d_hat <- opt$par[["d"]]
      
# h2 <- optimHess(
#   par = c(theta_hat, d_hat),
#   fn = function(par) {
#     return (
#       neg_log_lik(
#         theta = par[1],
#         d = par[2],
#         J = L$n_time_points,
#         theta_l_hat = theta_l_hat,
#         sigma_l_hat = sigma_l_hat
#       )
#     )
#   }
# )

      # !!!!! Debugging
      # optimHess(par, fn, gr = NULL, ..., control = list())
      
      # Use hessian to estimate SEs
      h <- hessian(
        func = function(par) {
          return (
            neg_log_lik(
              theta = par[1],
              d = par[2],
              J = L$n_time_points,
              theta_l_hat = theta_l_hat,
              sigma_l_hat = sigma_l_hat
            )
          )
        },
        c(theta_hat,d_hat)
      )

      se_theta_hat <- sqrt(solve(h)[1,1])
      # se_theta_hat <- ifelse(solve(h)[1,1]>0, sqrt(solve(h)[1,1]), NULL)
      se_d_hat <- sqrt(solve(h)[2,2])
      # se_d_hat <- ifelse(solve(h)[2,2]>0, sqrt(solve(h)[2,2]), NULL)

      # Construct theta_hat2 estimator (closed-form MLE of theta)
      l_times <- 1:(L$n_time_points-1)
      mu_d_hat <- 1-exp(-l_times/d_hat)
      theta_hat2 <- (t(theta_l_hat) %*% solve(sigma_l_hat) %*% mu_d_hat) /
        (t(mu_d_hat) %*% solve(sigma_l_hat) %*% mu_d_hat)
      
      # ggplot(theta_hats, aes(x=l, y=theta_l_est)) +
      #   geom_point(color="turquoise")
      
      return (list(
        d_hat = d_hat,
        theta_hat = theta_hat,
        theta_hat2 = theta_hat2,
        se_d_hat = se_d_hat,
        se_theta_hat = se_theta_hat
      ))
      
    }
  )
  
  sim %<>% run("one_simulation")
  
  summary(
    sim_obj = sim,
    sd = TRUE,
    coverage = list(
      list(name="theta", truth=L$theta,
           estimate=R$theta_hat, se=R$se_theta_hat),
      list(name="d", truth=C$d, estimate=R$d_hat, se=R$se_d_hat)
    )
  )
  
  print(paste("Time elapsed:", Sys.time()-start_time))
  
  # Plots
  # plot_sw_design(data_1)
  # plot_outcome(data_1, type="no error")
  # plot_outcome(data_1, type="realized")
  
}
```



# MAIN: Simulation 2: Effect lag exists but is not accounted for
```{r}
if ( run_main ) {
  
  # d \in {0.5, 1.4}
  # I, J, K, tau^2, theta, alpha, N as above
  # Same outputs as above
  
  # Check: The short and long lags should result in log RRs of log(0.55) and log(0.70) at the first time step
  
  # !!!!!
  
}
```



# MAIN: Simulation 3: Effect lag exists and is accounted for
```{r}
if ( run_main ) {
  
  # d \in {0.5, 1.4}
  # I, J, K, tau^2, theta, alpha, N as above
  # Same outputs as above
  
  # Check: The short and long lags should result in log RRs of log(0.55) and log(0.70) at the first time step
  
  # !!!!!
  
}
```



# MISC: Check MLE calculation
```{r}
if ( run_misc ) {
  
  J <- 5
  theta_hat_l <- matrix(1:J,ncol=1)
  mu_d <- matrix(0.3*c(3:(J+2)),ncol=1)
  A <- matrix(runif(J^2)*2-1, ncol=J)
  sigma_inv <- t(A) %*% A

  neg_log_lik <- function(theta) {
    return(
      (1/2) * t(theta_hat_l-(theta*mu_d)) %*%
        sigma_inv %*%
        (theta_hat_l-(theta*mu_d))
    )
  }
  
  optim(
    par = 6,
    fn = function(x) {
      return ( neg_log_lik(x) )
    },
    method = "BFGS"
  )
  
  mle_ank <- (
    (t(theta_hat_l) %*% sigma_inv %*% mu_d) +
      t((t(theta_hat_l) %*% sigma_inv %*% mu_d))) /
      (2* t(mu_d) %*% sigma_inv %*% mu_d)
  mle_tsg <- (t(theta_hat_l) %*% sigma_inv %*% mu_d) /
             (t(mu_d) %*% sigma_inv %*% mu_d)
  
  print(mle_ank)
  print(mle_tsg)
  
}
```



# MISC: Linear spline alternative
```{r}
if ( run_misc ) {
  
  ggplot(data.frame(x=c(0,8)), aes(x=x)) +
    # stat_function(fun = function(x) {
    #   return(ifelse(x>=2,1,0))
    # }, aes(color="Step function")) +
    # stat_function(fun = function(x) {
    #   d = 1
    #   I = ifelse(x>=1, 1, 0)
    #   return(I * (1-exp(-(x-1)/d)))
    # }, aes(color="Current function")) +
    stat_function(fun = function(x) {
      i1 = ifelse(x>=0 & x<2, 1, 0)
      i2 = ifelse(x>=2 & x<5, 1, 0)
      i3 = ifelse(x>=5, 1, 0)
      return( i1*(0.4*x) + i2*((0.2/3)*x + (2/3)) + i3 )
    }) +
    # }, aes(color="Linear spline")) +
    geom_point(aes(x=5, y=1), colour="green") +
    geom_point(aes(x=2, y=0.8), colour="purple") +
    labs(
      title = "Linear spline model for R_ij",
      # color = "Type",
      y = "R_ij (% of treatment effect achieved)",
      x = "Time (t_ij)"
    )
    
}
```


# ARCHIVE: Old code (to recycle) from run_analysis
```{r}
if ( FALSE ) {
  
  # # Testing
  # data <- generate_dataset(
  #   alpha = log(0.1),
  #   tau = 0,
  #   theta = log(0.5),
  #   d = 0.5,
  #   n_clusters = 48,
  #   n_time_points = 9,
  #   n_ind_per_cluster = 10,
  #   type = "normal",
  #   # type = "binomial",
  #   sigma = 0.1
  # )
  # plot_sw_design(data)
  # plot_outcome(data, type="no error")
  # plot_outcome(data, type="realized")
  # print(data$beta_js)
  # print(data$theta_ls)
  
  # # LMM code
  # model_lmm <- lme(
  #   fixed = y ~ factor(j) + factor(x_ij), # !!!!! Force beta_1=0
  #   random = ~1|i,
  #   data = data$data,
  #   # data = data,
  #   method = "ML"
  # )
  # summary(model_lmm)
  
  # # Binomial GLM
  # model_binomial_gee1 <- geeglm(
  #   y ~ factor(j) + factor(x_ij),
  #   data = data$data,
  #   id = i,
  #   family = binomial(link = "log"),
  #   corstr = "exchangeable"
  # )
  # summary(model_binomial_gee1)
  # system.time(
  #   model_binomial_gee2 <- geeglm(
  #     y ~ factor(j) + factor(l),
  #     data = data$data,
  #     id = i,
  #     family = binomial(link = "log"),
  #     corstr = "exchangeable"
  #   )
  # )
  # summary(model_gee2)
  
  # # Only estimate theta (step function)
  # model_normal_gee1 <- geeglm(
  #   y ~ factor(j) + factor(x_ij),
  #   data = data$data,
  #   id = i,
  #   family = "gaussian",
  #   corstr = "exchangeable"
  # )
  # summary(model_normal_gee1)
  
  
}
```
